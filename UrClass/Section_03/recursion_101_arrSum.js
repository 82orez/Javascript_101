// * 문제: 자연수로 이루어진 리스트(배열)를 입력받고, 리스트의 합을 리턴하는 함수 `arrSum` 을 작성하세요.

// ? 물론 재귀 없이 반복문으로 해결하는 방법도 있습니다.
function arrSumFor(arr) {
  let sumNum = 0;

  for (let i = 0; i < arr.length; i++) {
    sumNum += arr[i];
  }
    return sumNum;
}
console.log(arrSumFor([1, 2, 3, 4, 5]));

// * 하지만 이번 챕터는 재귀를 배우는 것이 목적이니, 차근차근 따라오며 재귀를 이해해보세요.
// * 우선 이론적으로 재귀로 문제를 해결하는 단계는 다음과 같습니다.

// ? 1. 문제를 좀 더 작게 쪼갭니다.
// ? 2. 1번과 같은 방식으로, 문제가 더는 작아지지 않을 때까지, 가장 작은 단위로 문제를 쪼갭니다.
// ? 3. 가장 작은 단위의 문제를 풂으로써 전체 문제를 해결합니다.

// * 이 단계를 적용해서 arrSum 함수를 작성해봅시다.
// * 일단 배열 [1, 2, 3, 4, 5] 의 합을 구하는 과정을 재귀로 풀어봅시다.


// * 1. 문제를 작게 쪼개기

// ? 어떻게하면 arrSum 함수로 [1, 2, 3, 4, 5] 의 합을 구하는 과정을 더 작게 쪼갤 수 있을까요?
// ? 단순하게 생각해보면, 배열의 합을 구할 때 [1, 2, 3, 4, 5] 의 합을 구하는 것보다 [2, 3, 4, 5] 의 합을 구하는 것이 더 작은 문제이고,
// ? 여기서 또 [2, 3, 4, 5] 의 합을 구하는 것보다 [3, 4, 5] 의 합을 구하는 것이 더 작은 문제일 것입니다.

// * 위 방식으로 문제를 쪼갠것을 코드로 표현하면 다음과 같습니다.

// ? arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5])
// ? arrSum([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5])
// ? arrSum([3, 4, 5]) === 3 + arrSum([4, 5])
// ? arrSum([4, 5]) === 4 + arrSum([5])
// ? arrSum([5]) === 5 + arrSum([])

// * 마지막에는 arrSum 이 빈 배열을 받게되면서 문제를 더이상 쪼갤 수 없게 되었죠?
// * 이로써 문제를 가장 작은 단위까지 쪼갰다고 할 수 있게 되었습니다.


// * 2. 문제 해결하기
// * 문제가 더 쪼개지지 않게되면, 가장 작은 단위의 문제를 해결합니다.
// * 문제를 쪼갤 때 같은 방식으로 쪼갰기 때문에, 가장 작은 단위의 문제를 해결한 방식으로 문제 전체를 해결할 수 있게 됩니다.

// * 2번에서 도달한 가장 작은 문제는 arrSum([]) 이었습니다.
// * 빈 배열의 합은 0이므로, 0을 리턴해주면 되겠죠?
// * 이렇게 가장 작은 문제를 해결하는 순간, 아래 코드처럼 쪼개졌던 문제가 거꾸로 거슬러 올라가면서 합쳐지게 됩니다.

// ? arrSum([]) === 0;

// ? 가장 작은 경우의 해결책을 적용합니다.
// arrSum([5]) === 5 + arrSum([]) === 5 + 0 === 5;
// arrSum([4, 5]) === 4 + arrSum([5]) === 4 + 5 === 9;
// arrSum([3, 4, 5]) === 3 + arrSum([4, 5]) === 3 + 9 === 12;
// arrSum([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5]) === 2 + 12 === 14;
// arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5]) === 1 + 14 === 15;

// * arrSum 함수의 리턴값이 나오면서 연쇄적으로 문제가 해결되고, 최종적으로는 문제 전체가 해결되는 것을 볼 수 있습니다.

// ! 실제 코드를 작성할 때는 2가지 사항을 유의해야 한다.
// * Part 1. base case: 재귀를 탈출할 수 있는 조건. 재귀의 마지막 부분.
// * Part 2. recursive case: 재귀(자기 자신을 호출)를 통해 문제를 작게 쪼개나가는 코드

function arrSum(arr) {
  // * Part 1. 빈 배열을 받았을 때 0을 리턴하는 조건문
  // ? --> 가장 작은 문제를 해결하는 코드 & 재귀를 멈추는 코드
  if (arr.length === 0) {
    return 0;
  }

  // * Part 2. 배열의 첫 요소 + 나머지 요소가 담긴 배열을 받는 arrSum 함수
  // ? --> 재귀(자기 자신을 호출)를 통해 문제를 작게 쪼개나가는 코드
  return arr.shift() + arrSum(arr);
}

console.log(arrSum([1, 2, 3, 4, 5]));

// ! 결국 다음과 같은 논리 구조를 가진다.

// * arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5])
// *                         === 1 + { 2 + arrSum([3, 4, 5]) }
// *                         === 1 + 2 + { 3 + arrSum([4, 5]) }
// *                         === 1 + 2 + 3 + { 4 + arrSum([5]) }
// *                         === 1 + 2 + 3 + 4 + { 5 + arrSum([]) }
// *                         === 1 + 2 + 3 + 4 + 5 + { 0 }
